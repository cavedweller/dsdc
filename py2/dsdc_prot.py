# -*-python-*-
# This file was automatically generated by rpcc.

class Procedure(object):
	__slots__ = [ 'pack_arg', 'unpack_arg', 'pack_res', 'unpack_res' ]

programs = {}

def pack_ptr(p, o, packf):
	if o is None:
		p.pack_uint(0)
	else:
		p.pack_uint(1)
		packf(o)
def unpack_ptr(u, unpackf):
	bit = u.unpack_uint()
	if bit:
		return unpackf()
	else:
		return None

def pack_void(p, o):
	pass
def unpack_void(u):
	return None

def pack_int(p, o):
	p.pack_int(o)
def unpack_int(u):
	return u.unpack_int()

def pack_uint(p, o):
	p.pack_uint(o)
def unpack_uint(u):
	return u.unpack_uint()

def pack_hyper(p, o):
	p.pack_hyper(o)
def unpack_hyper(u):
	return u.unpack_hyper()

def pack_uhyper(p, o):
	p.pack_uhyper(o)
def unpack_uhyper(u):
	return u.unpack_uhyper()

def pack_float(p, o):
	p.pack_float(o)
def unpack_float(u):
	return u.unpack_float()

def pack_double(p, o):
	p.pack_double(o)
def unpack_double(u):
	return u.unpack_double()

def pack_bool(p, o):
	p.pack_bool(o)
def unpack_bool(u):
	return u.unpack_bool()

def pack_u_int32_t(p, o):
	p.pack_uint(o)
def unpack_u_int32_t(u):
	return u.unpack_uint()

def pack_int32_t(p, o):
	p.pack_int(o)
def unpack_int32_t(u):
	return u.unpack_int()

def pack_u_int64_t(p, o):
	p.pack_uhyper(o)
def unpack_u_int64_t(u):
	return u.unpack_uhyper()

def pack_int64_t(p, o):
	p.pack_hyper(o)
def unpack_int64_t(u):
	return u.unpack_hyper()


def pack_ok_frobber_t(p, o):
	p.pack_uint(o)
def unpack_ok_frobber_t(u):
	return u.unpack_uint()

MATCHD_FRONTD_FROBBER = 0
MATCHD_FRONTD_USERCACHE_FROBBER = 1
UBER_USER_FROBBER = 2
PROFILE_STALKER_FROBBER = 3
MATCHD_FRONTD_MATCHCACHE_FROBBER = 4
GROUP_INFO_FROBBER = 5
GTEST_SCORE_FROBBER = 6
PTEST_SCORE_FROBBER = 7
MTEST_SCORE_FROBBER = 8
CUPID_TEST_SCORE_FROBBER = 9
GTEST_SESSION_FROBBER = 10
PTEST_SESSION_FROBBER = 11
MTEST_SESSION_FROBBER = 12
MTEST_METADATA_FROBBER = 13
MTEST_STATS_FROBBER = 14
SETTINGS_FROBBER = 15

class dsdc_key64_t(object):
	__slots__ = [ 'frobber', 'key64' ]
	def check(self):
		pass
		assert self.frobber is not None
		assert self.key64 is not None
	def __eq__(self, other):
		if not self.frobber == other.frobber: return 0
		if not self.key64 == other.key64: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_key64_t(p, o):
	o.check()
	pack_ok_frobber_t(p, o.frobber)
	pack_u_int64_t(p, o.key64)
def unpack_dsdc_key64_t(u):
	o = dsdc_key64_t()
	o.frobber = unpack_ok_frobber_t(u)
	o.key64 = unpack_u_int64_t(u)
	o.check()
	return o

class uber_key_t(object):
	__slots__ = [ 'frobber', 'userid', 'load_type' ]
	def check(self):
		pass
		assert self.frobber is not None
		assert self.userid is not None
		assert self.load_type is not None
	def __eq__(self, other):
		if not self.frobber == other.frobber: return 0
		if not self.userid == other.userid: return 0
		if not self.load_type == other.load_type: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_uber_key_t(p, o):
	o.check()
	pack_ok_frobber_t(p, o.frobber)
	pack_u_int64_t(p, o.userid)
	pack_u_int32_t(p, o.load_type)
def unpack_uber_key_t(u):
	o = uber_key_t()
	o.frobber = unpack_ok_frobber_t(u)
	o.userid = unpack_u_int64_t(u)
	o.load_type = unpack_u_int32_t(u)
	o.check()
	return o

#define MATCHD_NULL_QUESTION_ID 0

class matchd_qanswer_row_t(object):
	__slots__ = [ 'questionid', 'data' ]
	def check(self):
		pass
		assert self.questionid is not None
		assert self.data is not None
	def __eq__(self, other):
		if not self.questionid == other.questionid: return 0
		if not self.data == other.data: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_matchd_qanswer_row_t(p, o):
	o.check()
	pack_int32_t(p, o.questionid)
	pack_u_int32_t(p, o.data)
def unpack_matchd_qanswer_row_t(u):
	o = matchd_qanswer_row_t()
	o.questionid = unpack_int32_t(u)
	o.data = unpack_u_int32_t(u)
	o.check()
	return o

def pack_matchd_qanswer_rows_t(p, o):
	p.pack_array(o, lambda x: pack_matchd_qanswer_row_t(p, x))
def unpack_matchd_qanswer_rows_t(u):
	return u.unpack_array(lambda : unpack_matchd_qanswer_row_t(u))

class matchd_frontd_dcdc_arg_t(object):
	__slots__ = [ 'user_questions', 'userids' ]
	def check(self):
		pass
		assert self.user_questions is not None
		assert self.userids is not None
	def __eq__(self, other):
		if not self.user_questions == other.user_questions: return 0
		if not self.userids == other.userids: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_matchd_frontd_dcdc_arg_t(p, o):
	o.check()
	pack_matchd_qanswer_rows_t(p, o.user_questions)
	p.pack_array(o.userids, lambda x: pack_u_int64_t(p, x))
def unpack_matchd_frontd_dcdc_arg_t(u):
	o = matchd_frontd_dcdc_arg_t()
	o.user_questions = unpack_matchd_qanswer_rows_t(u)
	o.userids = u.unpack_array(lambda : unpack_u_int64_t(u))
	o.check()
	return o

class matchd_frontd_match_datum_t(object):
	__slots__ = [ 'userid', 'match_found', 'mpercent', 'fpercent', 'epercent' ]
	def check(self):
		pass
		assert self.userid is not None
		assert self.match_found is not None
		assert self.mpercent is not None
		assert self.fpercent is not None
		assert self.epercent is not None
	def __eq__(self, other):
		if not self.userid == other.userid: return 0
		if not self.match_found == other.match_found: return 0
		if not self.mpercent == other.mpercent: return 0
		if not self.fpercent == other.fpercent: return 0
		if not self.epercent == other.epercent: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_matchd_frontd_match_datum_t(p, o):
	o.check()
	pack_u_int64_t(p, o.userid)
	pack_bool(p, o.match_found)
	pack_int32_t(p, o.mpercent)
	pack_int32_t(p, o.fpercent)
	pack_int32_t(p, o.epercent)
def unpack_matchd_frontd_match_datum_t(u):
	o = matchd_frontd_match_datum_t()
	o.userid = unpack_u_int64_t(u)
	o.match_found = unpack_bool(u)
	o.mpercent = unpack_int32_t(u)
	o.fpercent = unpack_int32_t(u)
	o.epercent = unpack_int32_t(u)
	o.check()
	return o

class match_frontd_match_results_t(object):
	__slots__ = [ 'cache_misses', 'results' ]
	def check(self):
		pass
		assert self.cache_misses is not None
		assert self.results is not None
	def __eq__(self, other):
		if not self.cache_misses == other.cache_misses: return 0
		if not self.results == other.results: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_match_frontd_match_results_t(p, o):
	o.check()
	pack_int32_t(p, o.cache_misses)
	p.pack_array(o.results, lambda x: pack_matchd_frontd_match_datum_t(p, x))
def unpack_match_frontd_match_results_t(u):
	o = match_frontd_match_results_t()
	o.cache_misses = unpack_int32_t(u)
	o.results = u.unpack_array(lambda : unpack_matchd_frontd_match_datum_t(u))
	o.check()
	return o

#define DSDC_KEYSIZE 20
#define DSDC_DEFAULT_PORT 30002

def pack_dsdc_key_t(p, o):
	p.pack_fopaque(DSDC_KEYSIZE, o)
def unpack_dsdc_key_t(u):
	return u.unpack_fopaque(DSDC_KEYSIZE)

def pack_dsdc_keyset_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_key_t(p, x))
def unpack_dsdc_keyset_t(u):
	return u.unpack_array(lambda : unpack_dsdc_key_t(u))

def pack_dsdc_res_t(p, o):
	p.pack_uint(o)
def unpack_dsdc_res_t(u):
	return u.unpack_uint()

DSDC_OK = 0
DSDC_REPLACED = 1
DSDC_INSERTED = 2
DSDC_NOTFOUND = 3
DSDC_NONODE = 4
DSDC_ALREADY_REGISTERED = 5
DSDC_RPC_ERROR = 6
DSDC_DEAD = 7
DSDC_LOCKED = 8
DSDC_TIMEOUT = 9
DSDC_ERRDECODE = 10
DSDC_ERRENCODE = 11
DSDC_BAD_STATS = 12

def pack_dsdc_annotation_type_t(p, o):
	p.pack_uint(o)
def unpack_dsdc_annotation_type_t(u):
	return u.unpack_uint()

DSDC_NO_ANNOTATION = 0
DSDC_INT_ANNOTATION = 1

class dsdc_annotation_t(object):
	__slots__ = [ 'typ', 'i' ]
	def check(self):
		pass
		if self.typ == DSDC_INT_ANNOTATION:
			assert self.i is not None
	def __eq__(self, other):
		if not self.typ == other.typ: return 0
		if self.typ == DSDC_INT_ANNOTATION:
			if not self.i == other.i: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_annotation_t(p, o):
	o.check()
	pack_dsdc_annotation_type_t(p, o.typ)
	if o.typ == DSDC_INT_ANNOTATION:
		pack_int32_t(p, o.i)
def unpack_dsdc_annotation_t(u):
	o = dsdc_annotation_t()
	o.typ = unpack_dsdc_annotation_type_t(u)
	if o.typ == DSDC_INT_ANNOTATION:
		o.i = unpack_int32_t(u)
	o.check()
	return o

class dsdc_histogram_t(object):
	__slots__ = [ 'scale_factor', 'avg', 'min', 'max', 'buckets' ]
	def check(self):
		pass
		assert self.scale_factor is not None
		assert self.avg is not None
		assert self.min is not None
		assert self.max is not None
		assert self.buckets is not None
	def __eq__(self, other):
		if not self.scale_factor == other.scale_factor: return 0
		if not self.avg == other.avg: return 0
		if not self.min == other.min: return 0
		if not self.max == other.max: return 0
		if not self.buckets == other.buckets: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_histogram_t(p, o):
	o.check()
	pack_int64_t(p, o.scale_factor)
	pack_int64_t(p, o.avg)
	pack_int64_t(p, o.min)
	pack_int64_t(p, o.max)
	p.pack_array(o.buckets, lambda x: pack_u_int32_t(p, x))
def unpack_dsdc_histogram_t(u):
	o = dsdc_histogram_t()
	o.scale_factor = unpack_int64_t(u)
	o.avg = unpack_int64_t(u)
	o.min = unpack_int64_t(u)
	o.max = unpack_int64_t(u)
	o.buckets = u.unpack_array(lambda : unpack_u_int32_t(u))
	o.check()
	return o

class dsdc_dataset_t(object):
	__slots__ = [ 'creations', 'puts', 'missed_gets', 'gets', 'lifetime', 'objsz', 'do_gets', 'do_lifetime', 'do_objsz' ]
	def check(self):
		pass
		assert self.creations is not None
		assert self.puts is not None
		assert self.missed_gets is not None
		assert self.gets is not None
		assert self.lifetime is not None
		assert self.objsz is not None
		assert self.do_gets is not None
		assert self.do_lifetime is not None
		assert self.do_objsz is not None
	def __eq__(self, other):
		if not self.creations == other.creations: return 0
		if not self.puts == other.puts: return 0
		if not self.missed_gets == other.missed_gets: return 0
		if not self.gets == other.gets: return 0
		if not self.lifetime == other.lifetime: return 0
		if not self.objsz == other.objsz: return 0
		if not self.do_gets == other.do_gets: return 0
		if not self.do_lifetime == other.do_lifetime: return 0
		if not self.do_objsz == other.do_objsz: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_dataset_t(p, o):
	o.check()
	pack_int64_t(p, o.creations)
	pack_int64_t(p, o.puts)
	pack_int64_t(p, o.missed_gets)
	pack_dsdc_histogram_t(p, o.gets)
	pack_dsdc_histogram_t(p, o.lifetime)
	pack_dsdc_histogram_t(p, o.objsz)
	pack_dsdc_histogram_t(p, o.do_gets)
	pack_dsdc_histogram_t(p, o.do_lifetime)
	pack_dsdc_histogram_t(p, o.do_objsz)
def unpack_dsdc_dataset_t(u):
	o = dsdc_dataset_t()
	o.creations = unpack_int64_t(u)
	o.puts = unpack_int64_t(u)
	o.missed_gets = unpack_int64_t(u)
	o.gets = unpack_dsdc_histogram_t(u)
	o.lifetime = unpack_dsdc_histogram_t(u)
	o.objsz = unpack_dsdc_histogram_t(u)
	o.do_gets = unpack_dsdc_histogram_t(u)
	o.do_lifetime = unpack_dsdc_histogram_t(u)
	o.do_objsz = unpack_dsdc_histogram_t(u)
	o.check()
	return o

class dsdc_statistic_t(object):
	__slots__ = [ 'annotation', 'epoch_data', 'alltime_data' ]
	def check(self):
		pass
		assert self.annotation is not None
		assert self.epoch_data is not None
		assert self.alltime_data is not None
	def __eq__(self, other):
		if not self.annotation == other.annotation: return 0
		if not self.epoch_data == other.epoch_data: return 0
		if not self.alltime_data == other.alltime_data: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_statistic_t(p, o):
	o.check()
	pack_dsdc_annotation_t(p, o.annotation)
	pack_dsdc_dataset_t(p, o.epoch_data)
	pack_dsdc_dataset_t(p, o.alltime_data)
def unpack_dsdc_statistic_t(u):
	o = dsdc_statistic_t()
	o.annotation = unpack_dsdc_annotation_t(u)
	o.epoch_data = unpack_dsdc_dataset_t(u)
	o.alltime_data = unpack_dsdc_dataset_t(u)
	o.check()
	return o

def pack_dsdc_statistics_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_statistic_t(p, x))
def unpack_dsdc_statistics_t(u):
	return u.unpack_array(lambda : unpack_dsdc_statistic_t(u))

class dsdc_dataset_params_t(object):
	__slots__ = [ 'lifetime_n_buckets', 'gets_n_buckets', 'objsz_n_buckets' ]
	def check(self):
		pass
		assert self.lifetime_n_buckets is not None
		assert self.gets_n_buckets is not None
		assert self.objsz_n_buckets is not None
	def __eq__(self, other):
		if not self.lifetime_n_buckets == other.lifetime_n_buckets: return 0
		if not self.gets_n_buckets == other.gets_n_buckets: return 0
		if not self.objsz_n_buckets == other.objsz_n_buckets: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_dataset_params_t(p, o):
	o.check()
	pack_u_int32_t(p, o.lifetime_n_buckets)
	pack_u_int32_t(p, o.gets_n_buckets)
	pack_u_int32_t(p, o.objsz_n_buckets)
def unpack_dsdc_dataset_params_t(u):
	o = dsdc_dataset_params_t()
	o.lifetime_n_buckets = unpack_u_int32_t(u)
	o.gets_n_buckets = unpack_u_int32_t(u)
	o.objsz_n_buckets = unpack_u_int32_t(u)
	o.check()
	return o

class dsdc_get_stats_single_arg_t(object):
	__slots__ = [ 'params' ]
	def check(self):
		pass
		assert self.params is not None
	def __eq__(self, other):
		if not self.params == other.params: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_get_stats_single_arg_t(p, o):
	o.check()
	pack_dsdc_dataset_params_t(p, o.params)
def unpack_dsdc_get_stats_single_arg_t(u):
	o = dsdc_get_stats_single_arg_t()
	o.params = unpack_dsdc_dataset_params_t(u)
	o.check()
	return o

def pack_dsdc_hostname_t(p, o):
	p.pack_string(o)
def unpack_dsdc_hostname_t(u):
	return u.unpack_string()

def pack_dsdc_hostnames_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_hostname_t(p, x))
def unpack_dsdc_hostnames_t(u):
	return u.unpack_array(lambda : unpack_dsdc_hostname_t(u))

def pack_dsdc_settype_t(p, o):
	p.pack_uint(o)
def unpack_dsdc_settype_t(u):
	return u.unpack_uint()

DSDC_SET_NONE = 0
DSDC_SET_ALL = 1
DSDC_SET_SOME = 2
DSDC_SET_RANDOM = 3

class dsdc_slaveset_t(object):
	__slots__ = [ 'typ', 'hosts' ]
	def check(self):
		pass
		assert self.typ is not None
		if self.typ == DSDC_SET_SOME:
			assert self.hosts is not None
	def __eq__(self, other):
		if not self.typ == other.typ: return 0
		if self.typ == DSDC_SET_SOME:
			if not self.hosts == other.hosts: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_slaveset_t(p, o):
	o.check()
	pack_dsdc_settype_t(p, o.typ)
	if o.typ == DSDC_SET_SOME:
		pack_dsdc_hostnames_t(p, o.hosts)
def unpack_dsdc_slaveset_t(u):
	o = dsdc_slaveset_t()
	o.typ = unpack_dsdc_settype_t(u)
	if o.typ == DSDC_SET_SOME:
		o.hosts = unpack_dsdc_hostnames_t(u)
	o.check()
	return o

class dsdc_get_stats_arg_t(object):
	__slots__ = [ 'hosts', 'getparams' ]
	def check(self):
		pass
		assert self.hosts is not None
		assert self.getparams is not None
	def __eq__(self, other):
		if not self.hosts == other.hosts: return 0
		if not self.getparams == other.getparams: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_get_stats_arg_t(p, o):
	o.check()
	pack_dsdc_slaveset_t(p, o.hosts)
	pack_dsdc_get_stats_single_arg_t(p, o.getparams)
def unpack_dsdc_get_stats_arg_t(u):
	o = dsdc_get_stats_arg_t()
	o.hosts = unpack_dsdc_slaveset_t(u)
	o.getparams = unpack_dsdc_get_stats_single_arg_t(u)
	o.check()
	return o

class dsdc_get_stats_single_res_t(object):
	__slots__ = [ 'status', 'stats' ]
	def check(self):
		pass
		if self.status == DSDC_OK:
			assert self.stats is not None
	def __eq__(self, other):
		if not self.status == other.status: return 0
		if self.status == DSDC_OK:
			if not self.stats == other.stats: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_get_stats_single_res_t(p, o):
	o.check()
	pack_dsdc_res_t(p, o.status)
	if o.status == DSDC_OK:
		pack_dsdc_statistics_t(p, o.stats)
def unpack_dsdc_get_stats_single_res_t(u):
	o = dsdc_get_stats_single_res_t()
	o.status = unpack_dsdc_res_t(u)
	if o.status == DSDC_OK:
		o.stats = unpack_dsdc_statistics_t(u)
	o.check()
	return o

class dsdc_slave_statistic_t(object):
	__slots__ = [ 'host', 'stats' ]
	def check(self):
		pass
		assert self.host is not None
		assert self.stats is not None
	def __eq__(self, other):
		if not self.host == other.host: return 0
		if not self.stats == other.stats: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_slave_statistic_t(p, o):
	o.check()
	pack_dsdc_hostname_t(p, o.host)
	pack_dsdc_get_stats_single_res_t(p, o.stats)
def unpack_dsdc_slave_statistic_t(u):
	o = dsdc_slave_statistic_t()
	o.host = unpack_dsdc_hostname_t(u)
	o.stats = unpack_dsdc_get_stats_single_res_t(u)
	o.check()
	return o

def pack_dsdc_slave_statistics_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_slave_statistic_t(p, x))
def unpack_dsdc_slave_statistics_t(u):
	return u.unpack_array(lambda : unpack_dsdc_slave_statistic_t(u))

class dsdc_req_t(object):
	__slots__ = [ 'key', 'time_to_expire' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.time_to_expire is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.time_to_expire == other.time_to_expire: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_req_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_int32_t(p, o.time_to_expire)
def unpack_dsdc_req_t(u):
	o = dsdc_req_t()
	o.key = unpack_dsdc_key_t(u)
	o.time_to_expire = unpack_int32_t(u)
	o.check()
	return o

def pack_dsdc_custom_t(p, o):
	p.pack_opaque(o)
def unpack_dsdc_custom_t(u):
	return u.unpack_opaque()

class dsdc_key_template_t(object):
	__slots__ = [ 'id', 'pid', 'port', 'hostname' ]
	def check(self):
		pass
		assert self.id is not None
		assert self.pid is not None
		assert self.port is not None
		assert self.hostname is not None
	def __eq__(self, other):
		if not self.id == other.id: return 0
		if not self.pid == other.pid: return 0
		if not self.port == other.port: return 0
		if not self.hostname == other.hostname: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_key_template_t(p, o):
	o.check()
	pack_u_int32_t(p, o.id)
	pack_u_int32_t(p, o.pid)
	pack_u_int32_t(p, o.port)
	p.pack_string(o.hostname)
def unpack_dsdc_key_template_t(u):
	o = dsdc_key_template_t()
	o.id = unpack_u_int32_t(u)
	o.pid = unpack_u_int32_t(u)
	o.port = unpack_u_int32_t(u)
	o.hostname = u.unpack_string()
	o.check()
	return o

def pack_dsdc_obj_t(p, o):
	p.pack_opaque(o)
def unpack_dsdc_obj_t(u):
	return u.unpack_opaque()

class dsdc_put_arg_t(object):
	__slots__ = [ 'key', 'obj' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.obj is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.obj == other.obj: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_put_arg_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_dsdc_obj_t(p, o.obj)
def unpack_dsdc_put_arg_t(u):
	o = dsdc_put_arg_t()
	o.key = unpack_dsdc_key_t(u)
	o.obj = unpack_dsdc_obj_t(u)
	o.check()
	return o

class dsdc_get_res_t(object):
	__slots__ = [ 'status', 'obj', 'err' ]
	def check(self):
		pass
		if self.status == DSDC_OK:
			assert self.obj is not None
		elif self.status == DSDC_RPC_ERROR:
			assert self.err is not None
	def __eq__(self, other):
		if not self.status == other.status: return 0
		if self.status == DSDC_OK:
			if not self.obj == other.obj: return 0
		elif self.status == DSDC_RPC_ERROR:
			if not self.err == other.err: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_get_res_t(p, o):
	o.check()
	pack_dsdc_res_t(p, o.status)
	if o.status == DSDC_OK:
		pack_dsdc_obj_t(p, o.obj)
	elif o.status == DSDC_RPC_ERROR:
		pack_u_int32_t(p, o.err)
def unpack_dsdc_get_res_t(u):
	o = dsdc_get_res_t()
	o.status = unpack_dsdc_res_t(u)
	if o.status == DSDC_OK:
		o.obj = unpack_dsdc_obj_t(u)
	elif o.status == DSDC_RPC_ERROR:
		o.err = unpack_u_int32_t(u)
	o.check()
	return o

class dsdc_mget_1res_t(object):
	__slots__ = [ 'key', 'res' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.res is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.res == other.res: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_mget_1res_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_dsdc_get_res_t(p, o.res)
def unpack_dsdc_mget_1res_t(u):
	o = dsdc_mget_1res_t()
	o.key = unpack_dsdc_key_t(u)
	o.res = unpack_dsdc_get_res_t(u)
	o.check()
	return o

def pack_dsdc_mget_res_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_mget_1res_t(p, x))
def unpack_dsdc_mget_res_t(u):
	return u.unpack_array(lambda : unpack_dsdc_mget_1res_t(u))

def pack_dsdc_mget_arg_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_key_t(p, x))
def unpack_dsdc_mget_arg_t(u):
	return u.unpack_array(lambda : unpack_dsdc_key_t(u))

def pack_dsdc_mget2_arg_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_req_t(p, x))
def unpack_dsdc_mget2_arg_t(u):
	return u.unpack_array(lambda : unpack_dsdc_req_t(u))

def pack_dsdc_get_arg_t(p, o):
	pack_dsdc_key_t(p, o)
def unpack_dsdc_get_arg_t(u):
	return unpack_dsdc_key_t(u)

class dsdc_get3_arg_t(object):
	__slots__ = [ 'key', 'time_to_expire', 'annotation' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.time_to_expire is not None
		assert self.annotation is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.time_to_expire == other.time_to_expire: return 0
		if not self.annotation == other.annotation: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_get3_arg_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_int32_t(p, o.time_to_expire)
	pack_dsdc_annotation_t(p, o.annotation)
def unpack_dsdc_get3_arg_t(u):
	o = dsdc_get3_arg_t()
	o.key = unpack_dsdc_key_t(u)
	o.time_to_expire = unpack_int32_t(u)
	o.annotation = unpack_dsdc_annotation_t(u)
	o.check()
	return o

def pack_dsdc_mget3_arg_t(p, o):
	p.pack_array(o, lambda x: pack_dsdc_get3_arg_t(p, x))
def unpack_dsdc_mget3_arg_t(u):
	return u.unpack_array(lambda : unpack_dsdc_get3_arg_t(u))

class dsdc_put3_arg_t(object):
	__slots__ = [ 'key', 'obj', 'annotation' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.obj is not None
		assert self.annotation is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.obj == other.obj: return 0
		if not self.annotation == other.annotation: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_put3_arg_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_dsdc_obj_t(p, o.obj)
	pack_dsdc_annotation_t(p, o.annotation)
def unpack_dsdc_put3_arg_t(u):
	o = dsdc_put3_arg_t()
	o.key = unpack_dsdc_key_t(u)
	o.obj = unpack_dsdc_obj_t(u)
	o.annotation = unpack_dsdc_annotation_t(u)
	o.check()
	return o

class dsdcx_slave_t(object):
	__slots__ = [ 'keys', 'hostname', 'port' ]
	def check(self):
		pass
		assert self.keys is not None
		assert self.hostname is not None
		assert self.port is not None
	def __eq__(self, other):
		if not self.keys == other.keys: return 0
		if not self.hostname == other.hostname: return 0
		if not self.port == other.port: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdcx_slave_t(p, o):
	o.check()
	pack_dsdc_keyset_t(p, o.keys)
	p.pack_string(o.hostname)
	pack_int32_t(p, o.port)
def unpack_dsdcx_slave_t(u):
	o = dsdcx_slave_t()
	o.keys = unpack_dsdc_keyset_t(u)
	o.hostname = u.unpack_string()
	o.port = unpack_int32_t(u)
	o.check()
	return o

class dsdcx_state_t(object):
	__slots__ = [ 'slaves', 'lock_server' ]
	def check(self):
		pass
		assert self.slaves is not None
	def __eq__(self, other):
		if not self.slaves == other.slaves: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdcx_state_t(p, o):
	o.check()
	p.pack_array(o.slaves, lambda x: pack_dsdcx_slave_t(p, x))
	pack_ptr(p, o.lock_server, lambda x: pack_dsdcx_slave_t(p, x))
def unpack_dsdcx_state_t(u):
	o = dsdcx_state_t()
	o.slaves = u.unpack_array(lambda : unpack_dsdcx_slave_t(u))
	o.lock_server = unpack_ptr(u, lambda : unpack_dsdcx_slave_t(u))
	o.check()
	return o

class dsdc_register_arg_t(object):
	__slots__ = [ 'slave', 'primary', 'lock_server' ]
	def check(self):
		pass
		assert self.slave is not None
		assert self.primary is not None
		assert self.lock_server is not None
	def __eq__(self, other):
		if not self.slave == other.slave: return 0
		if not self.primary == other.primary: return 0
		if not self.lock_server == other.lock_server: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_register_arg_t(p, o):
	o.check()
	pack_dsdcx_slave_t(p, o.slave)
	pack_bool(p, o.primary)
	pack_bool(p, o.lock_server)
def unpack_dsdc_register_arg_t(u):
	o = dsdc_register_arg_t()
	o.slave = unpack_dsdcx_slave_t(u)
	o.primary = unpack_bool(u)
	o.lock_server = unpack_bool(u)
	o.check()
	return o

class dsdc_getstate_res_t(object):
	__slots__ = [ 'needupdate', 'state' ]
	def check(self):
		pass
		assert self.needupdate is not None
		if self.needupdate == true:
			assert self.state is not None
	def __eq__(self, other):
		if not self.needupdate == other.needupdate: return 0
		if self.needupdate == true:
			if not self.state == other.state: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_getstate_res_t(p, o):
	o.check()
	pack_bool(p, o.needupdate)
	if o.needupdate == true:
		pack_dsdcx_state_t(p, o.state)
def unpack_dsdc_getstate_res_t(u):
	o = dsdc_getstate_res_t()
	o.needupdate = unpack_bool(u)
	if o.needupdate == true:
		o.state = unpack_dsdcx_state_t(u)
	o.check()
	return o

class dsdc_lock_acquire_res_t(object):
	__slots__ = [ 'status', 'lockid', 'err' ]
	def check(self):
		pass
		if self.status == DSDC_OK:
			assert self.lockid is not None
		elif self.status == DSDC_RPC_ERROR:
			assert self.err is not None
	def __eq__(self, other):
		if not self.status == other.status: return 0
		if self.status == DSDC_OK:
			if not self.lockid == other.lockid: return 0
		elif self.status == DSDC_RPC_ERROR:
			if not self.err == other.err: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_lock_acquire_res_t(p, o):
	o.check()
	pack_dsdc_res_t(p, o.status)
	if o.status == DSDC_OK:
		pack_u_int64_t(p, o.lockid)
	elif o.status == DSDC_RPC_ERROR:
		pack_u_int32_t(p, o.err)
def unpack_dsdc_lock_acquire_res_t(u):
	o = dsdc_lock_acquire_res_t()
	o.status = unpack_dsdc_res_t(u)
	if o.status == DSDC_OK:
		o.lockid = unpack_u_int64_t(u)
	elif o.status == DSDC_RPC_ERROR:
		o.err = unpack_u_int32_t(u)
	o.check()
	return o

class dsdc_lock_acquire_arg_t(object):
	__slots__ = [ 'key', 'writer', 'block', 'timeout' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.writer is not None
		assert self.block is not None
		assert self.timeout is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.writer == other.writer: return 0
		if not self.block == other.block: return 0
		if not self.timeout == other.timeout: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_lock_acquire_arg_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_bool(p, o.writer)
	pack_bool(p, o.block)
	pack_u_int32_t(p, o.timeout)
def unpack_dsdc_lock_acquire_arg_t(u):
	o = dsdc_lock_acquire_arg_t()
	o.key = unpack_dsdc_key_t(u)
	o.writer = unpack_bool(u)
	o.block = unpack_bool(u)
	o.timeout = unpack_u_int32_t(u)
	o.check()
	return o

class dsdc_lock_release_arg_t(object):
	__slots__ = [ 'key', 'lockid' ]
	def check(self):
		pass
		assert self.key is not None
		assert self.lockid is not None
	def __eq__(self, other):
		if not self.key == other.key: return 0
		if not self.lockid == other.lockid: return 0
		return 1
	def __ne__(self, other):
		return not self == other
def pack_dsdc_lock_release_arg_t(p, o):
	o.check()
	pack_dsdc_key_t(p, o.key)
	pack_u_int64_t(p, o.lockid)
def unpack_dsdc_lock_release_arg_t(u):
	o = dsdc_lock_release_arg_t()
	o.key = unpack_dsdc_key_t(u)
	o.lockid = unpack_u_int64_t(u)
	o.check()
	return o

DSDC_PROG = 30002
programs[DSDC_PROG] = {}
DSDC_VERS = 1
programs[DSDC_PROG][DSDC_VERS] = {}
DSDC_NULL = 0
programs[DSDC_PROG][DSDC_VERS][DSDC_NULL] = proc = Procedure()
proc.pack_arg = pack_void
proc.unpack_arg = unpack_void
proc.pack_res = pack_void
proc.unpack_res = unpack_void
DSDC_PUT = 1
programs[DSDC_PROG][DSDC_VERS][DSDC_PUT] = proc = Procedure()
proc.pack_arg = pack_dsdc_put_arg_t
proc.unpack_arg = unpack_dsdc_put_arg_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_REMOVE = 2
programs[DSDC_PROG][DSDC_VERS][DSDC_REMOVE] = proc = Procedure()
proc.pack_arg = pack_dsdc_key_t
proc.unpack_arg = unpack_dsdc_key_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_GET = 3
programs[DSDC_PROG][DSDC_VERS][DSDC_GET] = proc = Procedure()
proc.pack_arg = pack_dsdc_get_arg_t
proc.unpack_arg = unpack_dsdc_get_arg_t
proc.pack_res = pack_dsdc_get_res_t
proc.unpack_res = unpack_dsdc_get_res_t
DSDC_MGET = 4
programs[DSDC_PROG][DSDC_VERS][DSDC_MGET] = proc = Procedure()
proc.pack_arg = pack_dsdc_mget_arg_t
proc.unpack_arg = unpack_dsdc_mget_arg_t
proc.pack_res = pack_dsdc_mget_res_t
proc.unpack_res = unpack_dsdc_mget_res_t
DSDC_REGISTER = 6
programs[DSDC_PROG][DSDC_VERS][DSDC_REGISTER] = proc = Procedure()
proc.pack_arg = pack_dsdc_register_arg_t
proc.unpack_arg = unpack_dsdc_register_arg_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_HEARTBEAT = 7
programs[DSDC_PROG][DSDC_VERS][DSDC_HEARTBEAT] = proc = Procedure()
proc.pack_arg = pack_void
proc.unpack_arg = unpack_void
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_NEWNODE = 8
programs[DSDC_PROG][DSDC_VERS][DSDC_NEWNODE] = proc = Procedure()
proc.pack_arg = pack_dsdcx_slave_t
proc.unpack_arg = unpack_dsdcx_slave_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_GETSTATE = 9
programs[DSDC_PROG][DSDC_VERS][DSDC_GETSTATE] = proc = Procedure()
proc.pack_arg = pack_dsdc_key_t
proc.unpack_arg = unpack_dsdc_key_t
proc.pack_res = pack_dsdc_getstate_res_t
proc.unpack_res = unpack_dsdc_getstate_res_t
DSDC_LOCK_ACQUIRE = 10
programs[DSDC_PROG][DSDC_VERS][DSDC_LOCK_ACQUIRE] = proc = Procedure()
proc.pack_arg = pack_dsdc_lock_acquire_arg_t
proc.unpack_arg = unpack_dsdc_lock_acquire_arg_t
proc.pack_res = pack_dsdc_lock_acquire_res_t
proc.unpack_res = unpack_dsdc_lock_acquire_res_t
DSDC_LOCK_RELEASE = 11
programs[DSDC_PROG][DSDC_VERS][DSDC_LOCK_RELEASE] = proc = Procedure()
proc.pack_arg = pack_dsdc_lock_release_arg_t
proc.unpack_arg = unpack_dsdc_lock_release_arg_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_GET2 = 12
programs[DSDC_PROG][DSDC_VERS][DSDC_GET2] = proc = Procedure()
proc.pack_arg = pack_dsdc_req_t
proc.unpack_arg = unpack_dsdc_req_t
proc.pack_res = pack_dsdc_get_res_t
proc.unpack_res = unpack_dsdc_get_res_t
DSDC_MGET2 = 13
programs[DSDC_PROG][DSDC_VERS][DSDC_MGET2] = proc = Procedure()
proc.pack_arg = pack_dsdc_mget2_arg_t
proc.unpack_arg = unpack_dsdc_mget2_arg_t
proc.pack_res = pack_dsdc_mget_res_t
proc.unpack_res = unpack_dsdc_mget_res_t
DSDC_GET3 = 14
programs[DSDC_PROG][DSDC_VERS][DSDC_GET3] = proc = Procedure()
proc.pack_arg = pack_dsdc_get3_arg_t
proc.unpack_arg = unpack_dsdc_get3_arg_t
proc.pack_res = pack_dsdc_get_res_t
proc.unpack_res = unpack_dsdc_get_res_t
DSDC_MGET3 = 15
programs[DSDC_PROG][DSDC_VERS][DSDC_MGET3] = proc = Procedure()
proc.pack_arg = pack_dsdc_mget3_arg_t
proc.unpack_arg = unpack_dsdc_mget3_arg_t
proc.pack_res = pack_dsdc_mget_res_t
proc.unpack_res = unpack_dsdc_mget_res_t
DSDC_PUT3 = 16
programs[DSDC_PROG][DSDC_VERS][DSDC_PUT3] = proc = Procedure()
proc.pack_arg = pack_dsdc_put3_arg_t
proc.unpack_arg = unpack_dsdc_put3_arg_t
proc.pack_res = pack_dsdc_res_t
proc.unpack_res = unpack_dsdc_res_t
DSDC_GET_STATS = 17
programs[DSDC_PROG][DSDC_VERS][DSDC_GET_STATS] = proc = Procedure()
proc.pack_arg = pack_dsdc_get_stats_arg_t
proc.unpack_arg = unpack_dsdc_get_stats_arg_t
proc.pack_res = pack_dsdc_slave_statistics_t
proc.unpack_res = unpack_dsdc_slave_statistics_t
DSDC_GET_STATS_SINGLE = 18
programs[DSDC_PROG][DSDC_VERS][DSDC_GET_STATS_SINGLE] = proc = Procedure()
proc.pack_arg = pack_dsdc_get_stats_single_arg_t
proc.unpack_arg = unpack_dsdc_get_stats_single_arg_t
proc.pack_res = pack_dsdc_get_stats_single_res_t
proc.unpack_res = unpack_dsdc_get_stats_single_res_t
DSDC_COMPUTE_MATCHES = 100
programs[DSDC_PROG][DSDC_VERS][DSDC_COMPUTE_MATCHES] = proc = Procedure()
proc.pack_arg = pack_matchd_frontd_dcdc_arg_t
proc.unpack_arg = unpack_matchd_frontd_dcdc_arg_t
proc.pack_res = pack_match_frontd_match_results_t
proc.unpack_res = unpack_match_frontd_match_results_t

